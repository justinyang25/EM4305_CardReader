C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE EMREADWRITECARD
OBJECT MODULE PLACED IN .\OutPut\EMReadWriteCard.obj
COMPILER INVOKED BY: C:\Program Files\Keil_v5\C51\BIN\C51.EXE User\EMReadWriteCard.c BROWSE INCDIR(.\Header) DEBUG OBJEC
                    -TEXTEND PRINT(.\Listing\EMReadWriteCard.lst) TABS(2) OBJECT(.\OutPut\EMReadWriteCard.obj)

line level    source

   1          #include"EMReadWriteCard.h"
   2          #include"Uart.h"
   3          
   4          ///////////////////////////////////////////////////////////////////
   5          //                        Ð´¿¨Ê±¼ä²ÎÊýus
   6          #define   Start_Gap     55    //¿ªÊ¼¼äÏ¶  
   7          #define   Write_Data1   32    //Ð´Êý¾Ý'1'
   8          #define   Write_DataH0  17    //Ð´Êý¾Ý'0'17 
   9          #define   Write_DataL0  23    //Ð´Êý¾Ý'0'23
  10          
  11          unsigned char EM_Buff[10];    //¶Á¿¨Êý¾Ý½ÓÊÕ»º³å
  12          unsigned int Card_Periodtime = 0;
  13          unsigned int Card_JumpTime = 0;
  14            
  15          void Delay_8nus(unsigned int n)
  16          {
  17   1          unsigned char i;
  18   1        
  19   1          do
  20   1          {
  21   2              i = 58;
  22   2              while (--i);
  23   2          }
  24   1          while(n--);  
  25   1      }
  26          
  27          void Delay_nus(unsigned int n)
  28          {
  29   1          TL0 = 0;TH0 = 0;TR0 = 1;
  30   1          while((TH0 * 256 + TL0) < n);
  31   1          TR0 = 0;
  32   1      }
  33          
  34          unsigned int LineCheck(unsigned char u_Byte, unsigned char u_Len)
  35          {
  36   1          unsigned char x;
  37   1          unsigned char Check_temp = 0; 
  38   1          unsigned int Check = 0;
  39   1        
  40   1          Check = (unsigned int)u_Byte & 0x00FF;
  41   1        
  42   1          for(x = 0; x < u_Len; x ++)
  43   1          {
  44   2              if(u_Byte & 0x01)   Check_temp ++;
  45   2              u_Byte = u_Byte >> 1;
  46   2          }
  47   1          
  48   1          if((Check_temp % 2) != 0)
  49   1          {
  50   2              switch(u_Len)
  51   2              {
  52   3                  case 0: 
  53   3                      break;
  54   3                  case 1: Check = Check | 0x0002;
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 2   

  55   3                      break;
  56   3                  case 2: Check = Check | 0x0004;                    
  57   3                      break;
  58   3                  case 3: Check = Check | 0x0008;
  59   3                      break;
  60   3                  case 4: Check = Check | 0x0010;
  61   3                      break;
  62   3                  case 5: Check = Check | 0x0020;
  63   3                      break;
  64   3                  case 6: Check = Check | 0x0040;
  65   3                      break;  
  66   3                  case 7: Check = Check | 0x0080;           
  67   3                      break;  
  68   3                  case 8: Check = Check | 0x0100;           
  69   3                      break;              
  70   3              }     
  71   2          }     
  72   1          return Check; 
  73   1      }
  74          
  75          unsigned char Columncheck(unsigned char *b_Byte, unsigned char Byte_Len)    //ÁÐÐ£Ñé
  76          {
  77   1          unsigned char x,y;
  78   1          unsigned char Check = 0;  
  79   1          unsigned char Check_temp = 0;
  80   1          
  81   1          for(x = 0;x < 8;x ++)
  82   1          {
  83   2              Check = Check << 1;
  84   2              Check_temp = 0;
  85   2            
  86   2              for(y = 0;y < Byte_Len;y ++)
  87   2              {
  88   3                  switch(x)
  89   3                  {
  90   4                      case 0: Check_temp = Check_temp ^ (b_Byte[y] & 0x80);
  91   4                          break;
  92   4                      case 1: Check_temp = Check_temp ^ (b_Byte[y] & 0x40);
  93   4                          break;
  94   4                      case 2: Check_temp = Check_temp ^ (b_Byte[y] & 0x20);
  95   4                          break;
  96   4                      case 3: Check_temp = Check_temp ^ (b_Byte[y] & 0x10);
  97   4                          break;
  98   4                      case 4: Check_temp = Check_temp ^ (b_Byte[y] & 0x08);
  99   4                          break;      
 100   4                      case 5: Check_temp = Check_temp ^ (b_Byte[y] & 0x04);
 101   4                          break;
 102   4                      case 6: Check_temp = Check_temp ^ (b_Byte[y] & 0x02);
 103   4                          break;
 104   4                      case 7: Check_temp = Check_temp ^ (b_Byte[y] & 0x01);
 105   4                          break;                
 106   4                  }
 107   3              }
 108   2              if(Check_temp != 0) Check = Check | 0x01;
 109   2          }
 110   1          return Check; 
 111   1      }
 112          //========================================================================
 113          // º¯Êý: void Write_bit(unsigned char x)
 114          // ÃèÊö: Ð´Ò»¸öÊý¾ÝÎ»
 115          // ²ÎÊý: x£ºÐ´ÈëµÄÊý¾Ý 0/1
 116          // ·µ»Ø: 
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 3   

 117          // °æ±¾: V1.0, 2017-9-23
 118          //========================================================================
 119          void Write_bit(unsigned char x)
 120          {
 121   1          if(x)
 122   1          {
 123   2              Carrier_On();             //¿ª´Å³¡
 124   2              Delay_8nus(Write_Data1);  //Î¬³ÖÊý¾Ý1µÄ´Å³¡Ê±¼ä
 125   2          }
 126   1          else
 127   1          {
 128   2              Carrier_On();             //¿ª´Å³¡
 129   2              Delay_8nus(Write_DataH0); //Î¬³ÖÊý¾Ý0µÄ¿ªÆô´Å³¡Ê±¼ä
 130   2              Carrier_Off();            //¹Ø±Õ´Å³¡
 131   2              Delay_8nus(Write_DataL0); //Î¬³ÖÊý¾Ý0µÄ¹Ø±Õ´Å³¡Ê±¼ä   
 132   2              Carrier_On();             //¿ª´Å³¡      
 133   2          } 
 134   1      }
 135          
 136          //========================================================================
 137          // º¯Êý: void Write_star(void)
 138          // ÃèÊö: ·¢ÆðÊ¼ÐÅºÅ
 139          // ²ÎÊý: 
 140          // ·µ»Ø: 
 141          // °æ±¾: V1.0, 2017-9-23
 142          //========================================================================
 143          void Write_star(void)
 144          { 
 145   1          Carrier_Off();
 146   1          Delay_8nus(Start_Gap);      //¿ªÆô³¡Ç¿410us
 147   1          Write_bit(0);
 148   1      }
 149          
 150          //========================================================================
 151          // º¯Êý: void Write_command(unsigned char command)
 152          // ÃèÊö: Ð´ÃüÁî×Ö
 153          // ²ÎÊý: command  Ð´£º0101 ¶Á£º1001 µÇÂ¼£º0011 ±£»¤£º1100 ½ûÓÃ£º1010º
 154          // ·µ»Ø: 
 155          // °æ±¾: V1.0, 2017-9-23
 156          //========================================================================
 157          void Write_command(unsigned char command)
 158          {
 159   1          unsigned char i;
 160   1          unsigned char mask = 0x08;
 161   1      
 162   1          for(i=0;i<4;i++)                
 163   1          {
 164   2              Write_bit(mask & command);         
 165   2              mask >>= 1;
 166   2          } 
 167   1      }
 168          //========================================================================
 169          // º¯Êý: void WriteNbtye(unsigned int dat,unsigned char bit_len)
 170          // ÃèÊö: Ð´Êý¾Ý
 171          // ²ÎÊý: dat Ð´ÈëµÄÖµ
 172          // ·µ»Ø: 
 173          // °æ±¾: V1.0, 2017-9-23
 174          //========================================================================
 175          void WriteNbtye(unsigned int dat,unsigned char bit_len)
 176          {
 177   1          unsigned char i;  
 178   1        
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 4   

 179   1          for(i = 0;i < bit_len;i ++)       //1¸öÐ£ÑéÎ»  ×î¸ßÎ»
 180   1          {
 181   2              Write_bit(dat & 0x0001);
 182   2              dat = dat >> 1;
 183   2          }
 184   1      }
 185          
 186          unsigned char EM43xxPatt(void)
 187          {
 188   1          unsigned char Patt_dat = 0;
 189   1          unsigned char scan_temp = 250;
 190   1          unsigned char ErrTimes = 0;
 191   1          unsigned int  Old_Time = 0;
 192   1          unsigned int  Period_Max = 0;
 193   1        
 194   1          Period_Max = Card_Periodtime + (Card_Periodtime / 2);
 195   1          bitin = INPORT;
 196   1        
 197   1          while(--scan_temp)
 198   1          {
 199   2              TL0 = 0;TH0 = 0;TR0 = 1;    //³õÊ¼»¯¶¨Ê±¼ÆÊýÆ÷ ¿ªÊ¼¼ÆÊ± 
 200   2              ErrTimes = 0;
 201   2              while(INPORT == bitin)
 202   2              {
 203   3                  ErrTimes ++;
 204   3                  Delay_8nus(1);
 205   3                  if(ErrTimes == 125) break; //1ms
 206   3              }
 207   2              bitin = INPORT;
 208   2              if(ErrTimes == 125)
 209   2              {
 210   3                  Patt_dat = 0;
 211   3                  continue; 
 212   3              }
 213   2              Old_Time = TH0 * 256 + TL0;
 214   2              TL0 = 0;TH0 = 0;
 215   2              if((Old_Time > (Card_Periodtime / 2)) && (Old_Time < Period_Max))      
 216   2              {
 217   3                  Patt_dat ++;
 218   3                  if(Patt_dat == 4)
 219   3                  {
 220   4                      TL0 = 0;TH0 = 0;TR0 = 0;
 221   4                      return 1;
 222   4                  }
 223   3              }
 224   2              else
 225   2              {
 226   3                  Patt_dat = 0;
 227   3              }
 228   2          }
 229   1          TL0 = 0;TH0 = 0;TR0 = 0;
 230   1          
 231   1          return 0; 
 232   1      }
 233          
 234          bit CheckDataEM4305(void)
 235          {
 236   1          unsigned char i,j;
 237   1          unsigned char idata B_buff[45] = {0};
 238   1          unsigned int idata Check_B[4] = {0};
 239   1        
 240   1          if(!EM43xxPatt())   return 0;
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 5   

 241   1          Delay_nus(Card_JumpTime);      //ÑÓÊ±3/4ÖÜÆÚÊ±¼ä (nRF * 3) / 4  * 8;
 242   1          
 243   1          for(i = 0 ; i < 45; i ++)
 244   1          {
 245   2              bitin = INPORT;
 246   2              if(bitin)  B_buff[i] = 1; 
 247   2              while(INPORT == bitin);   //µÈ´ýÌø±ä
 248   2              Delay_nus(Card_JumpTime); //ÑÓÊ±3/4ÖÜÆÚÊ±¼ä (nRF * 3) / 4  * 8;
 249   2          }
 250   1          
 251   1          for(i = 0; i < 4; i ++)         //4¸ö×Ö½ÚÊý¾Ý    
 252   1          {
 253   2               EM_Buff[3 - i] = 0;
 254   2               for(j = 0; j < 8; j ++)    //ÍùÒ»¸ö×Ö½ÚÐ´Î»
 255   2               {
 256   3                    EM_Buff[3 - i] = EM_Buff[3 - i] >> 1;
 257   3                    if(B_buff[i * 9 + j])  EM_Buff[3 - i] |= 0x80;
 258   3               }
 259   2          }
 260   1          EM_Buff[5] = 0;
 261   1          for(i = 0; i < 4; i ++)
 262   1          {
 263   2              EM_Buff[5] = EM_Buff[5] << 1;     //±£´æÐÐÐ£Ñé
 264   2              if(B_buff[i * 9 + 8])  EM_Buff[5] |= 0x01;
 265   2          }   
 266   1          EM_Buff[4] = 0;
 267   1          for(i = 0; i < 8; i ++)   //±£´æÁÐÐ£Ñé
 268   1          {
 269   2              EM_Buff[4] = EM_Buff[4] >> 1;
 270   2              if(B_buff[36 + i])  EM_Buff[4] |= 0x80;     
 271   2          }
 272   1            
 273   1          for(i = 0; i < 4; i ++)  Check_B[i] = LineCheck(EM_Buff[i], 8);  //¼ÆËãµÃµ½ÐÐÐ£ÑéÎ»ÔÚµÚ8bit
 274   1          for(i = 0; i < 4; i ++)
 275   1          {
 276   2              Check_B[i] = (Check_B[i] >> 8) & 0x00FF;
 277   2              B_buff[0] = (EM_Buff[5] >> i) & 0x01;
 278   2              if(Check_B[i] != B_buff[0])  return 0;
 279   2          }
 280   1          B_buff[0] = Columncheck(EM_Buff, 4);
 281   1      
 282   1          if(B_buff[0] != EM_Buff[4])     return 0;
 283   1          return 1;
 284   1      }
 285          
 286          void Set_ReadOperation(unsigned char _nRF)
 287          {
 288   1          switch(_nRF)
 289   1          {
 290   2              case 8: Card_Periodtime = (64 * (FOSC / 1000)) / 12 /1000;
 291   2                      Card_JumpTime = (48 * (FOSC / 1000)) / 12 /1000;
 292   2                      break;
 293   2              case 16:Card_Periodtime = (128 * (FOSC / 1000)) / 12 /1000;
 294   2                      Card_JumpTime = (96 * (FOSC / 1000)) / 12 /1000;
 295   2                      break;
 296   2              case 32:Card_Periodtime = (256 * (FOSC / 1000)) / 12 /1000;
 297   2                      Card_JumpTime = (192 * (FOSC / 1000)) / 12 /1000;
 298   2                      break;
 299   2              case 40:Card_Periodtime = (320 * (FOSC / 1000)) / 12 /1000;
 300   2                      Card_JumpTime = (240 * (FOSC / 1000)) / 12 /1000;
 301   2                      break;  
 302   2              case 64:Card_Periodtime = (512 * (FOSC / 1000)) / 12 /1000;
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 6   

 303   2                      Card_JumpTime = (384 * (FOSC / 1000)) / 12 /1000;
 304   2                      break;  
 305   2              default:Card_Periodtime = (512 * (FOSC / 1000)) / 12 /1000;
 306   2                      Card_JumpTime = (384 * (FOSC / 1000)) / 12 /1000;
 307   2                      break;  
 308   2          }
 309   1      }
 310          
 311          unsigned char ReadWriteEM4305(unsigned char _cardCom,unsigned char _block,unsigned long _blockData,unsigne
             -d char _nRF)
 312          {
 313   1          unsigned char i;
 314   1          unsigned int  blockBuff[5] = {0};
 315   1          union 
 316   1          {
 317   1              unsigned long L;          
 318   1              unsigned char B[4];
 319   1          }_enCard; 
 320   1          _enCard.L = _blockData;
 321   1          
 322   1          for(i = 0;i < 4;i ++) blockBuff[i] = LineCheck(_enCard.B[i], 8);  //¼ÆËãÐÐÐ£Ñé  
 323   1          blockBuff[4] = Columncheck(_enCard.B,4);    //¼ÆËãÁÐÐ£Ñé
 324   1          _block = LineCheck(_block & 0x0F, 6);         //¼ÆËãµØÖ·ÐÐÐ£Ñé 0100 0111
 325   1          
 326   1          Set_ReadOperation(_nRF);
 327   1          
 328   1          Write_star();               //Ð´ÆðÊ¼ÐÅºÅ
 329   1          switch(_cardCom)
 330   1          {
 331   2              case LoginCom:Write_command(LoginCom);         //Ð´µÇÂ½ÃüÁî ÑéÖ¤ÃÜÂë
 332   2                            break;
 333   2              case ReadCom: Write_command(ReadCom);          //Ð´¶ÁÃüÁî 
 334   2                            WriteNbtye(_block,7);            //·¢ËÍÐ´ÈëµÄµØÖ·  6bit + 1bitÐ£Ñé    
 335   2                            return CheckDataEM4305();        //¶ÁÊý¾Ý·µ»Ø
 336   2              case WriteCom:Write_command(WriteCom);         //·¢ËÍÐ´ÃüÁî ¿éÐ´
 337   2                            WriteNbtye(_block,7);            //·¢ËÍÐ´ÈëµÄµØÖ·  6bit + 1bitÐ£Ñé
 338   2                            break;    
 339   2              case ProtectCom: 
 340   2                            Write_command(ProtectCom);       //Ð´±£»¤ÃüÁî Ð´OTP¿é
 341   2                            break;
 342   2              case DisableCom:
 343   2                            Write_command(DisableCom);       //Ð´½ûÓÃÃüÁî
 344   2                            for(i = 0;i < 4;i ++)  blockBuff[i] = 0x00FF;
 345   2                            blockBuff[4] = 0;
 346   2                            break;          
 347   2          }
 348   1          for(i = 0;i < 4;i ++) WriteNbtye(blockBuff[i],9);    //Ð´Êý¾Ý 8bit + 1bitÐ£Ñé 
 349   1          WriteNbtye(blockBuff[4],8); //Ð´ÁÐÐ£Ñé 8bit
 350   1          Write_bit(0);                //Ð´½áÊø·û¡°0¡±
 351   1          if(_cardCom == DisableCom)   return 1;
 352   1          if(EM43xxPatt())  return 1;
 353   1          return 0;     //²Ù×÷Ê§°Ü
 354   1      }
 355          
 356          
 357          
 358          
 359          
 360          
 361          
 362          
 363          
C51 COMPILER V9.55   EMREADWRITECARD                                                       05/07/2021 13:17:31 PAGE 7   

 364          
 365          
 366          
 367          
 368          
 369          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1382    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      32
   IDATA SIZE       =   ----      53
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
